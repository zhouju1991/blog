<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>写程序的猫</title>
  
  
  <link href="http://blog.codingcat.com/atom.xml" rel="self"/>
  
  <link href="http://blog.codingcat.com/"/>
  <updated>2021-03-04T16:06:59.916Z</updated>
  <id>http://blog.codingcat.com/</id>
  
  <author>
    <name>CodingCat</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CentOS7下如何设置MySQL开机自启</title>
    <link href="http://blog.codingcat.com/2020/12/29/CentOS7%E4%B8%8B%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AEMySQL%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF/"/>
    <id>http://blog.codingcat.com/2020/12/29/CentOS7%E4%B8%8B%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AEMySQL%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF/</id>
    <published>2020-12-29T00:00:00.000Z</published>
    <updated>2021-03-04T16:06:59.916Z</updated>
    
    <content type="html"><![CDATA[<p>一般在部署完MySQL的时候都需要设置开机启动，本文讲解CentOS7下如何配置MySQL开机自启。</p><span id="more"></span><p>CentOS7和6及以前的版本不一样，下面推荐使用systemctl命令来管理服务而不是以前的service(虽然service还能用)，废话不多说，直接看怎么做吧</p><h3 id="创建服务文件"><a href="#创建服务文件" class="headerlink" title="创建服务文件"></a>创建服务文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;mysqld.service</span><br></pre></td></tr></table></figure><p>mysqld是服务的名字，可自定义，不过必须以.service结尾。</p><p>服务文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description&#x3D;MySQL Server</span><br><span class="line">Documentation&#x3D;man:mysqld(8)</span><br><span class="line">Documentation&#x3D;https:&#x2F;&#x2F;dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;5.7&#x2F;en&#x2F;using-systemd.html</span><br><span class="line">After&#x3D;network.target</span><br><span class="line">After&#x3D;syslog.target</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User&#x3D;mysql</span><br><span class="line">Group&#x3D;mysql</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin&#x2F;mysqld --defaults-file&#x3D;&#x2F;etc&#x2F;my.cnf</span><br><span class="line">LimitNOFILE &#x3D; 5000</span><br></pre></td></tr></table></figure><p>内容还是通俗易懂的，就不细说啦，需要注意的是ExecStart是启动MySQL的脚本，这里需要使用mysqld文件来启动，而不是使用service命令时的support-files/mysql.server，这里有个好处就是，在多实例又不想使用MySQL官方自带的mysqlmulti的时候，就很方便。</p><h3 id="配置开机自启"><a href="#配置开机自启" class="headerlink" title="配置开机自启"></a>配置开机自启</h3><p>创建好服务文件之后，开机自启就简单了，一条命令即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable mysqld</span><br></pre></td></tr></table></figure><p>同时还可以使用systemctl命令启停MySQL实例，是不是很方便呀，赶紧试试吧！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一般在部署完MySQL的时候都需要设置开机启动，本文讲解CentOS7下如何配置MySQL开机自启。&lt;/p&gt;</summary>
    
    
    
    <category term="MySQL" scheme="http://blog.codingcat.com/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://blog.codingcat.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>SQL注入介绍</title>
    <link href="http://blog.codingcat.com/2020/12/05/SQL%E6%B3%A8%E5%85%A5%E4%BB%8B%E7%BB%8D%E5%8F%8A%E9%A2%84%E9%98%B2/"/>
    <id>http://blog.codingcat.com/2020/12/05/SQL%E6%B3%A8%E5%85%A5%E4%BB%8B%E7%BB%8D%E5%8F%8A%E9%A2%84%E9%98%B2/</id>
    <published>2020-12-05T00:00:00.000Z</published>
    <updated>2021-03-04T16:06:59.920Z</updated>
    
    <content type="html"><![CDATA[<p>SQL 注入攻击是通过将恶意的SQL语句如添加、删除等插入到应用的输入参数中，经过后台解析后发送到数据库服务器上解析执行进行的攻击。本文以mysql为例，讨论SQL注入以及在Django中如何防止SQL注入。</p><span id="more"></span><h2 id="SQL注入介绍"><a href="#SQL注入介绍" class="headerlink" title="SQL注入介绍"></a>SQL注入介绍</h2><p>在Web程序中，一般都会有后台根据用户输入内容查找或者执行相关动作的场景，如登录时查询用户是否存在。后台在处理的时候可能是根据用户输入的用户名，拼接SQL之后到数据库查询来判断，这时，如果用户恶意输入不正确内容或内容本身存在问题，会导致应用程序崩溃，甚至是丢失数据等导致相关损失。即通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。这种场景就称为SQL注入。</p><h3 id="一个SQL注入的简单例子"><a href="#一个SQL注入的简单例子" class="headerlink" title="一个SQL注入的简单例子"></a>一个SQL注入的简单例子</h3><p>如执行一条SQL语句:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * </span><br><span class="line">  from tb_user </span><br><span class="line"> where username &#x3D; &#39;jacobzhou&#39;;</span><br></pre></td></tr></table></figure><p>其中jacobzhou是用户输入的值，此时可以得到正确的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * </span><br><span class="line">    -&gt;   from tb_user </span><br><span class="line">    -&gt;  where username &#x3D; &#39;jacobzhou&#39;;</span><br><span class="line">+------+-----------+----------+------+</span><br><span class="line">| id   | username  | password | age  |</span><br><span class="line">+------+-----------+----------+------+</span><br><span class="line">|    1 | jacobzhou | 123456   |   29 |</span><br><span class="line">+------+-----------+----------+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>但是，当用户输入错误的值，如jacobzhou’;drop table  tb_test;，如果使用的是字符串拼接的方式去执行，SQL语句就变成了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * </span><br><span class="line">  from tb_user </span><br><span class="line"> where username &#x3D; &#39;jacobzhou&#39;;drop table tb_test;&#39;;</span><br></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * </span><br><span class="line">    -&gt;   from tb_user </span><br><span class="line">    -&gt;  where username &#x3D; &#39;jacobzhou&#39;;drop table tb_test;&#39;;</span><br><span class="line">+------+-----------+----------+------+</span><br><span class="line">| id   | username  | password | age  |</span><br><span class="line">+------+-----------+----------+------+</span><br><span class="line">|    1 | jacobzhou | 123456   |   29 |</span><br><span class="line">+------+-----------+----------+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">ERROR 1051 (42S02): Unknown table &#39;db-platform.tb_test&#39;</span><br><span class="line">    &#39;&gt; </span><br></pre></td></tr></table></figure><p>以上就是一个SQL注入的例子，可以看到，如果db-platform.tb_test表存在，那就会被恶意删除。例子相对较极端，对于Django自带的connection来说，使用execute函数执行SQL语句的时候，每次只执行一条语句，后一条语句不会执行。因此上面的例子在Django中是不成立的，但是足以说明SQL注入所带来的安全风险。那SQL注入都有哪些方式，如何才能防止SQL注入呢？</p><h2 id="SQL注入原理"><a href="#SQL注入原理" class="headerlink" title="SQL注入原理"></a>SQL注入原理</h2><p>Web应用程序对于用户输入的数据和合法性没有严谨的判断，前端用户的输入直接传输给后端，攻击者通过构造不同的参数，形成不同的SQL语句来实现对数据库的任意操作。<br>SQL注入产生需要满足两个条件：</p><ul><li>参数用户可控：前端传给后端的参数内容是用户可以控制的</li><li>参数带入数据库查询：传入的参数直接拼接到SQL语句，且带入数据库查询</li></ul><h2 id="SQL注入类型"><a href="#SQL注入类型" class="headerlink" title="SQL注入类型"></a>SQL注入类型</h2><p>SQL注入的分类有很多，如POST注入、Cookie注入、延时注入、搜索注入等，但是归根结底也是数字型和字符型注入的不同展现形式或者是注入的位置不同。</p><h3 id="数字型"><a href="#数字型" class="headerlink" title="数字型"></a>数字型</h3><p>用户输入为整数，假设SQL语句为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from home_application_database where id &#x3D; 3; </span><br></pre></td></tr></table></figure><p>其中3为数字，是用户正常输入。</p><p>当满足如下条件，则可能存在数字型注入：</p><ul><li>输入3’ 页面报错（SQL语法错误）</li><li>输入3 and 1 = 1 页面正常返回结果</li><li>输入3 and 1=2 页面返回错误（SQL语句返回空数据）</li></ul><p>如果后台使用的是<code>select * from home_application_database where id = </code>和未经验证的用户输入做拼接后去数据库查询，就满足了上面的三个条件，存在数字型注入。</p><p>这里可以看到用户输入必须是整数，后端验证用户输入必须是整数才会继续执行即可解决。</p><h3 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h3><p>用户输入是字符串，如SQL语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from home_application_database where name &#x3D; &#39;154&#39;</span><br></pre></td></tr></table></figure><p>其中154是字符串，是用户正常输入。</p><p>当满足如下条件时，则可能存在字符型注入：</p><ul><li>输入154’，页面异常（SQL语句语法错误）</li><li>输入154’ and 1 = 1 – ，页面正常返回</li><li>输入154’ and 1 = 2 – ，页面错误（查询结果为空）</li></ul><p>同数字型，如果后台直接使用拼接语句的形式去数据库执行，则就满足了上面单个条件，存在字符型注入。攻击者使用单引号的方式提前结束前一个单引号，并使用and来添加其他操作。</p><h2 id="如何防止SQL注入"><a href="#如何防止SQL注入" class="headerlink" title="如何防止SQL注入"></a>如何防止SQL注入</h2><p>在开发时应该秉持一种<strong>外部参数皆不可信</strong>的原则来进行开发。</p><ul><li><p>加强参数验证</p><p>开发时，验证所有来自前端的输入，必须是符合要求的数据类型，符合指定规则的数据才允许继续往下执行。</p></li><li><p>SQL语句参数化处理</p><p>减少使用或不使用字符串拼接的方式执行SQL，而是将用户输入当着参数传给执行SQL的方法，如Django中的cursor.execute()函数就支持在SQL语句中使用占位符，将输入作为参数传递给方法执行。</p></li><li><p>存储过程</p><p>使用存储过程也可以有效防止SQL注入，不过在存储过程中，需使用占位符，并且使用输入参数来预编译SQL语句后再执行。</p></li></ul><h2 id="Django中防止SQL注入"><a href="#Django中防止SQL注入" class="headerlink" title="Django中防止SQL注入"></a>Django中防止SQL注入</h2><p>Django中使用ORM可以有效防止SQL注入，所以应该尽可能使用ORM。但是ORM对于复杂查询就无能为力了，这时就需要执行原生SQL时，可以使用如下方式：</p><ol><li>使用extra（不建议使用这种方式执行SQL）</li><li>使用raw</li><li>使用django.db执行自定义SQL</li><li>直接使用pymysql</li></ol><p>在使用原生SQL语句时，应避免直接使用用户输入拼接SQL语句，上面三种执行原生SQL的方式均提供了占位符来进行参数替换，防止SQL注入。我们比较常用的是3、和4，两种方法都是使用cursor.execue()方法，具体如下：</p><ul><li><p>django.db</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> connection</span><br><span class="line">cursor = connection.cursor()</span><br><span class="line">cursor.execute(sql)</span><br><span class="line">result = cursor.fetchall()</span><br></pre></td></tr></table></figure></li><li><p>pymysql</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">connection = pymysql.connect(**mysql_server)</span><br><span class="line">cursor = connection.cursor()</span><br><span class="line">cursor.execute(sql)</span><br><span class="line">result = cursor.fetchall()</span><br></pre></td></tr></table></figure><p>execute中的sql语句使用占位符，并传入相应参数即可防止SQL注入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sql&#x3D;&quot;select * from home_application_database where id &#x3D; %s&quot; </span><br><span class="line">cursor.execute(sql,3)</span><br><span class="line">1</span><br><span class="line">cursor.execute(sql,&quot;3&#39;&quot;)</span><br><span class="line">1</span><br><span class="line">E:\venv\python2\lib\site-packages\pymysql\cursors.py:297: Warning: Truncated incorrect DOUBLE value: &#39;3&#39;&#39;</span><br><span class="line">  self._do_get_result()</span><br><span class="line">cursor.execute(sql,&quot;3 and 1 &#x3D; 1 &quot;)</span><br><span class="line">E:\venv\python2\lib\site-packages\pymysql\cursors.py:297: Warning: Truncated incorrect DOUBLE value: &#39;3 and 1 &#x3D; 1 &#39;</span><br><span class="line">1</span><br><span class="line">  self._do_get_result()</span><br><span class="line">cursor.execute(sql,&quot;3 and 1 &#x3D; 2 &quot;)</span><br><span class="line">E:\venv\python2\lib\site-packages\pymysql\cursors.py:297: Warning: Truncated incorrect DOUBLE value: &#39;3 and 1 &#x3D; 2 &#39;</span><br><span class="line">  self._do_get_result()</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>从上面执行结果看出，对于整数型注入，使用execute中带参数执行的方式，并不满足注入条件，当使用3’，3 and 1 = 1 ，3 and 1 = 2 作为输入传给execute执行时，程序报错。</p><p>同理对于字符型注入也一样。</p><blockquote><p>注意：在使用execute函数执行时，SQL语句中的占位符，不管是字符还是整型，都使用%s，且对于字符型的数据，在SQL语句里面不能使用’%s’，否则会报错。使用参数替换本质上是对输入的参数进行转义处理，防止输入中的引号。</p></blockquote></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;SQL 注入攻击是通过将恶意的SQL语句如添加、删除等插入到应用的输入参数中，经过后台解析后发送到数据库服务器上解析执行进行的攻击。本文以mysql为例，讨论SQL注入以及在Django中如何防止SQL注入。&lt;/p&gt;</summary>
    
    
    
    <category term="数据库 - MySQL" scheme="http://blog.codingcat.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL/"/>
    
    
    <category term="MySQL" scheme="http://blog.codingcat.com/tags/MySQL/"/>
    
    <category term="SQL注入" scheme="http://blog.codingcat.com/tags/SQL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>MySQL忘记root密码怎么办</title>
    <link href="http://blog.codingcat.com/2020/10/23/MySQL%E5%BF%98%E8%AE%B0root%E5%AF%86%E7%A0%81%E6%80%8E%E4%B9%88%E5%8A%9E/"/>
    <id>http://blog.codingcat.com/2020/10/23/MySQL%E5%BF%98%E8%AE%B0root%E5%AF%86%E7%A0%81%E6%80%8E%E4%B9%88%E5%8A%9E/</id>
    <published>2020-10-23T00:00:00.000Z</published>
    <updated>2021-03-04T16:06:59.920Z</updated>
    
    <content type="html"><![CDATA[<p>使用MySQL过程中我们偶尔会遇到忘记密码的情况，怎么办呢？能不能吧密码找回来或者重新设置密码呢？</p><span id="more"></span><p>MySQL忘记root密码之后，可以重新设置一个新的密码，怎么做呢？</p><ol><li><p>修改配置文件my.cnf，在[mysqld]下面增加参数：skip-grant-tables（启动 MySQL 服务的时候跳过权限表认证。启动后，连接到 MySQL 的 root 将不需要口令。），重启MySQL服务，免密码登录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@ocp11g~]# vi &#x2F;etc&#x2F;my.cnf    </span><br><span class="line">[root@ocp11g~]# service mysql restart</span><br><span class="line">Shuttingdown MySQL.... SUCCESS!</span><br><span class="line">StartingMySQL.. SUCCESS!</span><br><span class="line">[root@ocp11g~]# mysql -uroot</span><br><span class="line">Welcometo the MySQL monitor. Commands end with; or \g.</span><br><span class="line">YourMySQL connection id is 2</span><br><span class="line">Serverversion: 5.7.26-log MySQL Community Server (GPL)</span><br><span class="line">Copyright(c) 2000, 2019, Oracle and&#x2F;or its affiliates. All rights reserved.</span><br><span class="line">Oracleis a registered trademark of Oracle Corporation and&#x2F;or its</span><br><span class="line">affiliates.Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line">Type&#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.</span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure></li><li><p>修改root用户密码为空</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;alter user root@localhost identified by &#39;123456&#39;;</span><br><span class="line">ERROR1290 (HY000): The MySQL server is running with the --skip-grant-tables optionso it cannot execute this statement</span><br><span class="line">mysql&gt;update user set authentication_string &#x3D; NULL where user &#x3D; &#39;root&#39;;</span><br><span class="line">ERROR1046 (3D000): No database selected</span><br><span class="line">mysql&gt;use mysql</span><br><span class="line">Readingtable information for completion of table and column names</span><br><span class="line">Youcan turn off this feature to get a quicker startup with -A</span><br><span class="line">Databasechanged</span><br><span class="line">mysql&gt;update user set authentication_string &#x3D; NULL where user &#x3D; &#39;root&#39;;</span><br><span class="line">QueryOK, 1 row affected (0.01 sec)</span><br><span class="line">Rowsmatched: 1 Changed: 1 Warnings: 0</span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure></li><li><p>修该配置文件删除skip-grant-tables参数，重启MySQL服务，使用空密码登录，修改root密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@ocp11g~]# vi &#x2F;etc&#x2F;my.cnf    </span><br><span class="line">[root@ocp11g~]# service mysql restart</span><br><span class="line">Shuttingdown MySQL.. SUCCESS!</span><br><span class="line">StartingMySQL. SUCCESS!</span><br><span class="line">[root@ocp11g~]# mysql -uroot</span><br><span class="line">Welcometo the MySQL monitor. Commands end with; or \g.</span><br><span class="line">YourMySQL connection id is 3</span><br><span class="line">Serverversion: 5.7.26-log MySQL Community Server (GPL)</span><br><span class="line">Copyright(c) 2000, 2019, Oracle and&#x2F;or its affiliates. All rights reserved.</span><br><span class="line">Oracleis a registered trademark of Oracle Corporation and&#x2F;or its</span><br><span class="line">affiliates.Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line">Type&#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.</span><br><span class="line">mysql&gt;alter user root@localhost identified by &#39;123456&#39;;</span><br><span class="line">QueryOK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure></li><li><p>密码修改完成，MySQL root密码已修改，MySQL正常使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@ocp11g~]# mysql -uroot</span><br><span class="line">ERROR1045 (28000): Access denied for user &#39;root&#39;@&#39;localhost&#39; (using password: NO)</span><br><span class="line">[root@ocp11g~]# mysql -uroot -p</span><br><span class="line">Enterpassword:</span><br><span class="line">Welcometo the MySQL monitor. Commands end with; or \g.</span><br><span class="line">YourMySQL connection id is 5</span><br><span class="line">Serverversion: 5.7.26-log MySQL Community Server (GPL)</span><br><span class="line">Copyright(c) 2000, 2019, Oracle and&#x2F;or its affiliates. All rights reserved.</span><br><span class="line">Oracleis a registered trademark of Oracle Corporation and&#x2F;or its</span><br><span class="line">affiliates.Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line">Type&#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.</span><br><span class="line">mysql&gt;exit</span><br><span class="line">Bye</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用MySQL过程中我们偶尔会遇到忘记密码的情况，怎么办呢？能不能吧密码找回来或者重新设置密码呢？&lt;/p&gt;</summary>
    
    
    
    <category term="数据库 - MySQL" scheme="http://blog.codingcat.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL/"/>
    
    
    <category term="MySQL" scheme="http://blog.codingcat.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Oracle数据库关闭的情况下如何修改参数</title>
    <link href="http://blog.codingcat.com/2020/10/20/Oracle%E5%85%B3%E9%97%AD%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%E5%8F%82%E6%95%B0/"/>
    <id>http://blog.codingcat.com/2020/10/20/Oracle%E5%85%B3%E9%97%AD%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%E5%8F%82%E6%95%B0/</id>
    <published>2020-10-20T00:00:00.000Z</published>
    <updated>2021-03-04T16:06:59.920Z</updated>
    
    <content type="html"><![CDATA[<p>很多时候由于误操作，修改了某些参数后，重启数据库发现无法启动，需要将参数修改回来或者其他操作后才能正常启动，但是在数据库关闭的情况下，无法使用alter system等命令来修改参数，到底需要怎么做呢？</p><span id="more"></span><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>在Oracle中很多参数在修改的时候都有一定的规定，如在设置快速恢复区时，db_recovery_file_dest和db_recovery_file_dest_size需修改后重启数据库，如果只修改了db_recovery_file_dest，db_recovery_file_dest_size并不设定值，则无法重启数据库，启动时报错如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; startup </span><br><span class="line">ORA-19802: cannot use DB_RECOVERY_FILE_DEST without DB_RECOVERY_FILE_DEST_SIZE</span><br></pre></td></tr></table></figure><p>由于数据库已关闭，这时候也无法修改参数db_recovery_file_dest_size：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; alter system set db_recovery_file_dest_size&#x3D;4G scope&#x3D;spfile;</span><br><span class="line">alter system set db_recovery_file_dest_size&#x3D;4G scope&#x3D;spfile</span><br><span class="line">*</span><br><span class="line">ERROR at line 1:</span><br><span class="line">ORA-01034: ORACLE not available</span><br><span class="line">Process ID: 0</span><br><span class="line">Session ID: 0 Serial number: 0</span><br></pre></td></tr></table></figure><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>遇到上面类似修改参数之后无法启动数据库的情况，可以通过修改参数文件来解决。在Oracle中，有spfile和pfile两种参数文件，spfile是不可编辑的，正常情况下数据库使用的是spfile，pfile可以编辑，Oracle中可以通过spfile和pfile来相互创建，因此可以通过这个方法来解决此问题。</p><p>首先，使用已有的pfile来启动数据库，如果没有，可以根据其他数据库的内容来手动创建：startup pfile=’’</p><p>启动后，使用create pfile=’新的pfile文件’ from spfile=’原来的spfile文件’，此时的数据库状态不一定非得OPEN。</p><p>然后修改新建的pfile文件，确保参数都正确修改，如上面的例子，删除db_recovery_file_dest所在的行</p><p>关闭数据库并使用新的pfile文件启动数据库：startup pfile=’新的pfile’;</p><p>创建spfile文件：create spfile=’spfile文件’ from pfile=’新的pfile文件’;</p><p>关闭数据库，正常启动：startup</p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; show parameter db_recovery            </span><br><span class="line"></span><br><span class="line">NAME                                 TYPE        VALUE</span><br><span class="line">------------------------------------ ----------- ------------------------------</span><br><span class="line">db_recovery_file_dest                string</span><br><span class="line">db_recovery_file_dest_size           big integer 0</span><br><span class="line">SQL&gt; alter system set db_recovery_file_dest&#x3D;&#39;&#x2F;u01&#x2F;app&#x2F;oracle&#x2F;fast_recovery_area&#39; scope&#x3D;spfile;</span><br><span class="line"></span><br><span class="line">System altered.</span><br><span class="line">SQL&gt; shutdown immediate</span><br><span class="line">Database closed.</span><br><span class="line">Database dismounted.</span><br><span class="line">ORACLE instance shut down.</span><br><span class="line">SQL&gt; startup </span><br><span class="line">ORA-19802: cannot use DB_RECOVERY_FILE_DEST without DB_RECOVERY_FILE_DEST_SIZE</span><br><span class="line">SQL&gt; alter system set db_recovery_file_dest_size&#x3D;4G scope&#x3D;spfile;</span><br><span class="line">alter system set db_recovery_file_dest_size&#x3D;4G scope&#x3D;spfile</span><br><span class="line">*</span><br><span class="line">ERROR at line 1:</span><br><span class="line">ORA-01034: ORACLE not available</span><br><span class="line">Process ID: 0</span><br><span class="line">Session ID: 0 Serial number: 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SQL&gt; startup pfile&#x3D;&#39;&#x2F;u01&#x2F;app&#x2F;oracle&#x2F;product&#x2F;19.3.0&#x2F;db_1&#x2F;dbs&#x2F;init.ora&#39;</span><br><span class="line">ORACLE instance started.</span><br><span class="line"></span><br><span class="line">Total System Global Area 1073737800 bytes</span><br><span class="line">Fixed Size                  8904776 bytes</span><br><span class="line">Variable Size             616562688 bytes</span><br><span class="line">Database Buffers          440401920 bytes</span><br><span class="line">Redo Buffers                7868416 bytes</span><br><span class="line">ORA-00205: error in identifying control file, check alert log for more info</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SQL&gt; select status from v$instance;</span><br><span class="line"></span><br><span class="line">STATUS</span><br><span class="line">------------</span><br><span class="line">STARTED</span><br><span class="line"></span><br><span class="line">SQL&gt; create pfile&#x3D;&#39;&#x2F;u01&#x2F;app&#x2F;oracle&#x2F;product&#x2F;19.3.0&#x2F;db_1&#x2F;dbs&#x2F;init-20201020.ora&#39; from spfile&#x3D;&#39;&#x2F;u01&#x2F;app&#x2F;oracle&#x2F;product&#x2F;19.3.0&#x2F;db_1&#x2F;dbs&#x2F;spfileorcl.ora&#39;;</span><br><span class="line"></span><br><span class="line">File created.</span><br><span class="line"></span><br><span class="line">SQL&gt; shutdown immediate </span><br><span class="line">ORA-01507: database not mounted</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ORACLE instance shut down.</span><br><span class="line">SQL&gt; </span><br></pre></td></tr></table></figure><p>修改文件/u01/app/oracle/product/19.3.0/db_1/dbs/init-20201020.ora，删除db_recovery_file_dest所在的行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; startup pfile&#x3D;&#39;&#x2F;u01&#x2F;app&#x2F;oracle&#x2F;product&#x2F;19.3.0&#x2F;db_1&#x2F;dbs&#x2F;init-20201020.ora&#39;</span><br><span class="line">ORACLE instance started.</span><br><span class="line"></span><br><span class="line">Total System Global Area 1593832624 bytes</span><br><span class="line">Fixed Size                  9135280 bytes</span><br><span class="line">Variable Size             973078528 bytes</span><br><span class="line">Database Buffers          603979776 bytes</span><br><span class="line">Redo Buffers                7639040 bytes</span><br><span class="line">Database mounted.</span><br><span class="line">Database opened.</span><br><span class="line"></span><br><span class="line">SQL&gt; create spfile&#x3D;&#39;&#x2F;u01&#x2F;app&#x2F;oracle&#x2F;product&#x2F;19.3.0&#x2F;db_1&#x2F;dbs&#x2F;spfileorcl.ora&#39; from pfile&#x3D;&#39;&#x2F;u01&#x2F;app&#x2F;oracle&#x2F;product&#x2F;19.3.0&#x2F;db_1&#x2F;dbs&#x2F;init-20201020.ora&#39;;</span><br><span class="line"></span><br><span class="line">File created.</span><br><span class="line"></span><br><span class="line">SQL&gt; </span><br><span class="line">SQL&gt; shutdown immediate </span><br><span class="line">Database closed.</span><br><span class="line">Database dismounted.</span><br><span class="line">ORACLE instance shut down.</span><br><span class="line">SQL&gt; startup </span><br><span class="line">ORACLE instance started.</span><br><span class="line"></span><br><span class="line">Total System Global Area 1593832624 bytes</span><br><span class="line">Fixed Size                  9135280 bytes</span><br><span class="line">Variable Size             973078528 bytes</span><br><span class="line">Database Buffers          603979776 bytes</span><br><span class="line">Redo Buffers                7639040 bytes</span><br><span class="line">Database mounted.</span><br><span class="line">Database opened.</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;很多时候由于误操作，修改了某些参数后，重启数据库发现无法启动，需要将参数修改回来或者其他操作后才能正常启动，但是在数据库关闭的情况下，无法使用alter system等命令来修改参数，到底需要怎么做呢？&lt;/p&gt;</summary>
    
    
    
    <category term="数据库 - Oracle" scheme="http://blog.codingcat.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-Oracle/"/>
    
    
    <category term="Oracle" scheme="http://blog.codingcat.com/tags/Oracle/"/>
    
  </entry>
  
  <entry>
    <title>MySQL索引介绍</title>
    <link href="http://blog.codingcat.com/2020/10/09/MySQL%E7%B4%A2%E5%BC%95%E4%BB%8B%E7%BB%8D/"/>
    <id>http://blog.codingcat.com/2020/10/09/MySQL%E7%B4%A2%E5%BC%95%E4%BB%8B%E7%BB%8D/</id>
    <published>2020-10-09T15:14:32.000Z</published>
    <updated>2021-03-04T16:06:59.920Z</updated>
    
    <content type="html"><![CDATA[<p>一般情况下，数据库做了两件事情：存储数据和检索数据。检索数据是数据库中使用最多的一个功能。本篇文主要讨论MySQL数据库中InnoDB存储引擎下的索引的原理和使用。本文主要从以下几个方面展开：</p><img src="/2020/10/09/MySQL%E7%B4%A2%E5%BC%95%E4%BB%8B%E7%BB%8D/%E6%96%87%E7%AB%A0%E5%A4%A7%E7%BA%B2.png" class="" title="文章大纲"><span id="more"></span><h2 id="索引的概念"><a href="#索引的概念" class="headerlink" title="索引的概念"></a>索引的概念</h2><p>MySQL官方对索引的解释是这样的，原文如下：</p><p>Indexes are used to find rows with specific column values quickly. Without an index, MySQL must begin with the first row and then read through the entire table to find the relevant rows. The larger the table, the more this costs. If the table has an index for the columns in question, MySQL can quickly determine the position to seek to in the middle of the data file without having to look at all the data. This is much faster than reading every row sequentially.</p><p>翻译如下：</p><p>索引是用来快速查找特定列为具体的值的行的。没有索引，MySQL必须从头到尾扫描整张表来找打相关的行。表越大，消耗越大。如果查询列上有索引，MySQL能够快速的确定要查找数据所在数据文件的具体位置而不用扫描所有数据，这比按顺序读取每一行数据快很多。</p><p>简单的来说，索引就像书本的目录，通过目录可以快速的确定要查找内容的具体位置。通过索引，加快查询速度，降低查询消耗。</p><p>MySQL中的索引是存储引擎实现的，每种存储引擎使用的索引不同。以下只讨论InnoDB中的索引。</p><h2 id="InnoDB索引原理"><a href="#InnoDB索引原理" class="headerlink" title="InnoDB索引原理"></a>InnoDB索引原理</h2><p>InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+树中的。每一个索引在 InnoDB 里面对应一棵 B+ 树。数据存储在叶子节点上。详细结构如下：</p><p><img src="B+%E6%A0%91%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84.jpg" alt="B+树索引结构"></p><h2 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h2><p>索引可以有很多类型，如聚簇索引、非聚簇索引、唯一索引、复合索引、全文索引、空间索引等，在此只讨论聚簇索引和非聚簇索引。</p><h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>在InnoDB表中，数据是按照主键索引的顺序来组织的，这种表称为索引组织表，而主键索引称为聚簇索引。创建表后，如果表上有主键，则聚簇索引就是主键索引，否则使用非空唯一索引来创建聚簇索引，没有主键也没有非空唯一索引，InnoDB会创建一个隐藏的自增ID来作为聚簇索引的字段。一张表只能有一个聚簇索引。</p><p>聚簇索引的非叶子节点存放每一个键的值，叶子节点存放每一行的数据。</p><h3 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h3><p>除了聚簇索引之外的索引都可以称为辅助索引，辅助索引和聚簇索引的区别在于，辅助索引的叶子节点存储的是主键的键值，一张表可以有多个辅助索引。使用辅助索引来查找数据时，一般需要经过两个过程：一是通过辅助索引查找到对应的主键值，二是通过主键值去查找到需要的数据，这个过程称为回表。当创建的索引上包含多个字段，覆盖了要查找的字段时，查询不需要回表就可以查询到需要的数据，这种索引称为覆盖索引。</p><h2 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li><p>提高数据检索的效率,降低数据库的IO成本</p><p>在数据库查询的过程中，本质上是尽量减少查找的数据量，降低磁盘IO来提高查询的效率。</p></li><li><p>通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。</p><p>当对数据进行排序时，如果排序字段没有索引，将消耗大量的CPU来进行排序操作。数据库较大的情况下甚至会使用磁盘来进行排序，查询效率低下。</p></li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li><p>索引会占用磁盘空间</p><p>索引也是一张表，表中保存了主键和索引字段，</p></li><li><p>降低更新效率</p><p>在对表做更新操作的时候，MySQL不仅要保存数据，还需要保存索引，每次更新有索引的字段，都会因为更新的键值改变索引的信息。</p></li></ul><h2 id="如何利用索引来优化查询"><a href="#如何利用索引来优化查询" class="headerlink" title="如何利用索引来优化查询"></a>如何利用索引来优化查询</h2><p>既然索引可以提高查询效率，那是否在所有列上都建立索引就可以了？答案是不一定。并不是所有的索引都能够提高查询效率。那如何建立合适的索引来提高查询效率？</p><p>索引的建立需要符合以下原则：</p><ul><li>查询频次较高，且数据量较大的表</li><li>尽量使用唯一索引</li><li>选择区分度较高的列建立索引</li><li>对于建立索引的表，更新不应频繁</li><li>选择索引列时应选择where条件或者on子句中使用的字段</li><li>可以使用覆盖索引，避免回表操作</li><li>表记录较少（如配置表）或者字段区分度较低（如性别）时不应建立索引</li><li>字段值较长时不建议建立索引（可以考虑建立前缀索引）</li><li>查询中的排序字段应该创建索引</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;一般情况下，数据库做了两件事情：存储数据和检索数据。检索数据是数据库中使用最多的一个功能。本篇文主要讨论MySQL数据库中InnoDB存储引擎下的索引的原理和使用。本文主要从以下几个方面展开：&lt;/p&gt;
&lt;img src=&quot;/2020/10/09/MySQL%E7%B4%A2%E5%BC%95%E4%BB%8B%E7%BB%8D/%E6%96%87%E7%AB%A0%E5%A4%A7%E7%BA%B2.png&quot; class=&quot;&quot; title=&quot;文章大纲&quot;&gt;</summary>
    
    
    
    <category term="数据库 - MySQL" scheme="http://blog.codingcat.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL/"/>
    
    
    <category term="MySQL" scheme="http://blog.codingcat.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>如何升级MySQL</title>
    <link href="http://blog.codingcat.com/2020/09/24/%E5%A6%82%E4%BD%95%E5%8D%87%E7%BA%A7MySQL/"/>
    <id>http://blog.codingcat.com/2020/09/24/%E5%A6%82%E4%BD%95%E5%8D%87%E7%BA%A7MySQL/</id>
    <published>2020-09-24T00:00:00.000Z</published>
    <updated>2021-03-04T16:06:59.920Z</updated>
    
    <content type="html"><![CDATA[<p>数据库运行过程中，新版本不断的开发出来，低版本不断被淘汰，在已经运行的业务系统数据库中，我们是否应该升级数据库，升级需要考虑些什么问题呢？</p><span id="more"></span><h2 id="数据库是否应该升级"><a href="#数据库是否应该升级" class="headerlink" title="数据库是否应该升级"></a>数据库是否应该升级</h2><p>在准备对数据库升级之前，需要考虑一下几个问题，升级对业务有什么好处？有什么影响？然后再决定是否升级。在考虑是否升级前，需要对整体评估升级版本后能够解决什么样的问题。同时会带来什么样的问题，避免为了升级而升级。</p><h3 id="MySQL数据库升级会带来什么好处？"><a href="#MySQL数据库升级会带来什么好处？" class="headerlink" title="MySQL数据库升级会带来什么好处？"></a>MySQL数据库升级会带来什么好处？</h3><p><strong>是否能解决业务上的痛点</strong></p><p>业务上，升级可能会带来性能上的提升，当然也可能下降，5.6中有个叫performance_schema的库，默认是不开启的，开启此库会增加数据库系统的负担降低数据库性能，不过在5.7中经过优化，对性能的影响几乎可以忽略了。再如8.0中，提升了安全性，同时也支持在很多关系数据库中已经支持的窗口函数，对于数据统计分析的功能支持更好了。</p><p><strong>是否能解决运维上的痛点</strong></p><p>在运维上，更新的版本多少会带来些新的功能，减轻运维压力，比如MySQL5.7中增加了sys库，相比于5.7之前的版本中，通过sys库可以更好的监控数据库相关的指标。</p><h3 id="升级会有什么影响"><a href="#升级会有什么影响" class="headerlink" title="升级会有什么影响"></a>升级会有什么影响</h3><p><strong>对原来业务的支持是否影响</strong></p><p>不同版本之间的jdbc不一样，如8.0版本和5.7版本，当升级到8.0之后，相应的应用程序也应该一并升级处理，修改连接数据库的驱动。另外，不同版本之间参数可能不一致，如sql_mode，在不同的版本中默认值不一样，对SQL的处理方式不一样，导致SQL执行结果报错或者不符合预想的情况，另外有些参数在高版本中已经失效禁用了，在升级到新版本后，将无法启动数据库。</p><p><strong>对原来业务性能是否有影响</strong></p><p>上面提到过performance_schema库会对性能有影响，另外，当升级后需要注意InnoDB优化器对SQL语句的处理，不同版本优化方法不一样，可能会不能使用索引导致性能下降。</p><h2 id="如何升级MySQL"><a href="#如何升级MySQL" class="headerlink" title="如何升级MySQL"></a>如何升级MySQL</h2><h3 id="制定一个可行的升级方案"><a href="#制定一个可行的升级方案" class="headerlink" title="制定一个可行的升级方案"></a>制定一个可行的升级方案</h3><p>当评估了升级会带来的好处和影响后，确定要升级的话需要制定一个可行的升级方案了。</p><p><strong>评估受影响的业务系统</strong></p><p>一般情况下，一个数据库可能会有不同的业务系统使用，在升级前需要确定收到影响的系统，并在升级前通知到位，确保在升级的过程中如果有任何问题都可以找到相关的人来解决或者验证。</p><p><strong>升级的详细步骤</strong></p><p>对于线上系统的升级，是个紧张且重要的事情，不能出任何差错，因此一个详细的操作步骤是必不可少的。在实际的操作方案中，需要详细到可以直接从方案中复制来使用。大致的步骤如下：</p><ol><li><p>对待升级数据库进行备份</p></li><li><p>升级Slave服务器版本</p></li><li><p>手动进行主从切换</p></li><li><p>升级Master服务器版本</p></li><li><p>升级完成后进行业务检查</p></li><li><p>升级后的数据库检查（配置文件、数据库对象、操作系统）</p></li><li><p>升级后的业务检查</p></li></ol><p><strong>升级失败回滚方案</strong></p><p>俗话说，天有不测风云，虽然不一定能够遇到，但是要准备好在遇到的时候能够处变不惊。一个失败回滚的方案是必不可少的，大致步骤如下：</p><ol><li><p>升级失败回滚的步骤，详细的回滚失败处理步骤</p></li><li><p>回滚后数据库环境检查</p></li><li><p>回滚后的业务检查</p></li></ol><h3 id="实施升级方案"><a href="#实施升级方案" class="headerlink" title="实施升级方案"></a>实施升级方案</h3><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于线上系统的升级，是个高危影响大的操作，在制定方案的时候需要详细到每一个操作步骤都写清楚，要考虑到所有的情况。更重要的一点，需要在实际线上操作之前按照事先写好的方案文档实际操作并修改不当的地方。对于主从复制的升级，需要注意一点是高版本的MySQL数据库能够作为低版本的从库来使用，反之则会出问题，因此需要先升级从库。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;数据库运行过程中，新版本不断的开发出来，低版本不断被淘汰，在已经运行的业务系统数据库中，我们是否应该升级数据库，升级需要考虑些什么问题呢？&lt;/p&gt;</summary>
    
    
    
    <category term="数据库 - MySQL" scheme="http://blog.codingcat.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL/"/>
    
    
    <category term="MySQL" scheme="http://blog.codingcat.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL性能优化之key_buffer_size</title>
    <link href="http://blog.codingcat.com/2020/09/23/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8Bkey_buffer_size/"/>
    <id>http://blog.codingcat.com/2020/09/23/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8Bkey_buffer_size/</id>
    <published>2020-09-23T00:00:00.000Z</published>
    <updated>2021-03-04T16:06:59.920Z</updated>
    
    <content type="html"><![CDATA[<p>MyISAM表中的索引块在所有线程之间缓存和共享，key_buffer_size用来设置索引块使用的缓冲大小，key buffer也称key cache，key buffer用来缓存MyISAM表经常使用的索引。</p><span id="more"></span><p>在32位平台上key_buffer_size最大可设置为4294967295B，即4G，64位平台更大。根据操作系统和硬件平台实际可用的RAM，实际生效的值比设置的值偏小。该值的大小即为MySQL申请的内存大小，内部会为该变量尽可能分配内存以达到该值，实际上分配的可能会偏小。</p><p>该参数大小决定索引处理的速度，尤其是索引读的速度，在只使用MyISAM存储引擎的数据库中，可以将该值设置为机器总内存的25%，不宜设置过大（大于及其总内存的50% ），这样的话系统会频繁切换内存块（MySQL依赖操作系统缓存来缓存数据，因此需要留点空间给操作系统），导致系统变慢，如果有使用其他的存储引擎，也需要将其他存储引擎的内存使用考虑进去。</p><p>key_buffer_size是个全局参数，只对MyISAM表有作用，因为MySQL中磁盘临时表使用的是MyISAM引擎，因此也需要使用到该值，对于1G内存的机器，如果不使用MyISAM表，推荐值是16M（8-64M）。</p><p>可以通过show status，检查Key_read_requests, Key_reads, Key_write_requests, 以及Key_writes 状态变量的值来检查key buffer的性能，正常情况下，Key_reads/Key_read_requests的值应该小于0.01。Key_reads是从磁盘读取索引块到key cache的次数，Key_read_requests是请求读取索引块的次数，Key_reads较大，即Key_reads/Key_read_requests大于0.01时，可以增加key_buffer_size的值使其小于0.01来提升查询性能。更新多的时候Key_writes/Key_write_requests的值接近1，如果更新影响很多行或者使用DELAY_KEY_WRITE表选项时，Key_writes/Key_write_requests的值会更小。</p><p>通过公式1 - ((Key_blocks_unused * key_cache_block_size) / key_buffer_size)可以计算出索引块使用率，其中Key_blocks_unused 表示未使用的索引块数key_cache_block_size表示索引块大小。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;MyISAM表中的索引块在所有线程之间缓存和共享，key_buffer_size用来设置索引块使用的缓冲大小，key buffer也称key cache，key buffer用来缓存MyISAM表经常使用的索引。&lt;/p&gt;</summary>
    
    
    
    <category term="数据库 - MySQL" scheme="http://blog.codingcat.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL/"/>
    
    
    <category term="MySQL" scheme="http://blog.codingcat.com/tags/MySQL/"/>
    
  </entry>
  
</feed>
